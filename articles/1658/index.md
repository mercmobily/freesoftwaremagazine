---
nid: '1658'
title: 'Free your mind — write some free software'
authors: 'Terry Hancock'
published: '2006-08-05 0:00:00'
tags: 'programming,languages'
license: verbatim_only
section: hacking
listed: 'true'

---
Back when I got my first computer (a TRS-80 “Color Computer” with a whopping 32 kilobytes of RAM and Microsoft’s “MS-BASIC” in ROM), programming was something that computer users took for granted they’d have to do. That’s what you _got_ a computer for! But something dark and sinister happened after that: a great divide opened up between the ‘developer’ lords and the ‘user’ serfs.

Fortunately, free software has liberated us from this digital feudalism, and revived a new middle class of ‘user-developers’.


<!--break-->


If you really want to know what’s so cool about free software, you need to participate. It’s never been easier—there are, as has been famously noted, no silver bullets to ease software development, but many incremental improvements in programming languages for ‘scripting’ and ‘middleware’ have been made—these languages can make programming a real joy. And I think you will find it a liberating experience.

I’m a do-it-yourselfer from a family of do-it-yourselfers, so it’s possible that my perspective is unusual. But the reality is that things are often not so difficult as professionals—who have a vested interest in keeping you dependent—will make you think. Oh, sure, there are jobs I’m not going to do for myself, because I know a pro will do a better job; or because I don’t want to spend the time on it; or because I really don’t care that much about the particulars.

Sometimes the motivation for doing things yourself is saving money—either in the short term, because I don’t have to pay a pro to do the job, or in the long run—because knowing your equipment well saves time and money (the latter is why I always build my own computers). Sometimes it’s getting more exactly what you want. Sometimes it’s just the joy of doing it yourself.

Honestly, how hard can it be? Another human being figured out how to do it, so should you be able to, too. There’s a wonderful liberating feeling in just breaking out your tools and going to work on a problem instead of having to depend on someone else to do it for you.

In the digital world, that’s what being able to program provides for you. And whereas learning to do that on your own is a lonely and often daunting process, learning to do it in collaboration—under the friendly, free-exchange culture that free software licenses allow—is downright fun.


## The perfect language

There isn’t one.

But there are a lot of nice options. Now I could try to sell you on my personal favorite, which is Python, but that’s missing the point. The _point_ is that programming has gotten easier. Much easier.

When I started out, personal computer programs were often written in BASIC, and certainly BASIC was what you typically started with as a do-it-yourself programmer.

Anybody with any coding experience at all, though, can tell you that BASIC is a terrible programming language. Yes, in one sense it is very ‘basic’ in that there are few statements and expressions to learn, and the program flow control is pretty simple. But that’s precisely the problem: the lack of sophisticated program flow concepts like ‘functions’ and ‘procedures’ and of data abstraction concepts like ‘structures’ (let alone ‘objects’) makes anything more than short scripts impossible to figure out.

Nevertheless, I did quite a lot with BASIC back in my youth. And then I graduated to Fortran when I went to college. I was an engineering and science student, so I didn’t have to worry about all those pesky software guys complaining about the poor design of the Fortran language, we just went to town. I had a lot of fun writing a data-reduction tool for the McDonald Observatory Planet Search program (MOPS, although they hadn’t actually coined that name until a while after I left).

Still, it really is a poorly-designed language. Other languages like Lisp and Pascal and C brought different insights into computer science, along with the acid test of production development (which, for example favored C, but killed Pascal). Then came the ‘object-oriented’ craze with Smalltalk and Java and C++. Then there was the devil-may-care attitude of the Perl scripters who called their language the “duct tape of the internet” and themselves “perl-mongers”. They didn’t invent ‘regular expressions’, but they made them sing.

Now it’s well-known that all of these languages, movements, and styles promised sweeping improvements in productivity and revolutionary new powers of expression. It’s also well-known that they all failed to deliver on those wild promises.

What is less well appreciated is that they all succeeded in advancing the state of the art, and while the revolution never came, evolution happened. Life is what happens while you’re making plans. And programming got easier, more powerful, more ready-made.

A modern language, like Ruby, or my favorite Python, makes life easy. There are huge libraries that can dice the potatoes, crack the eggs, and heat up the saucepan—so that actually making the omelets has become embarrassingly easy. You owe it to yourself to learn one of these easy languages, even if you don’t plan to ever program professionally.


## ‘Knowledge architects’?, _oh come on!_

Back when I started programming, people who wrote programs were called ‘programmers’. There were no ‘coders’, ‘computing consultants’, ‘software engineers’, or ‘database application programmers’, or ‘knowledge architects’ (or at least I was blissfully ignorant of such pretentious titles).

I’m not saying that code didn’t get written, database applications programmed, or software engineered. I’m just saying that people weren’t so hyper-specialized, nor was there so much professional mystique built around the processes of software development. What we have seen is the professionalization of the field—the erection of guilds with coded passwords and shibboleths to keep out the unbelievers.

Or as [Thornten Wilder](http://en.wikipedia.org/wiki/Thornton_Wilder) put it, “Wherever you come near the human race there’s layers and layers of nonsense”[*](http://en.wikipedia.org/wiki/Our_Town). The realities of programming for pay in a proprietary software development world make it necessary as a matter of career-maintenance to overcomplicate, overspecialize, and obfuscate the practice of writing software. The reason that world has produced so few truly easy and expressive programming languages is because its language developers have a fundamental vested interest in not succeeding at doing so.

Fortunately, the dynamics of the free software world are different: here, there’s always a need for more developers and for users to become developers. The fastest way to ingratiate yourself with free developers is to stop being a dependent and “submit a patch”. That’s why the most amazing and powerful programming languages have come from free software: Perl, Python, Ruby, and Scheme were all born and raised here.

Or you can make a whole lot of friends among users and developers alike by finding a simple problem and solving it simply: typically by using one of these late-generation scripting languages.


## Getting paid is good, but free communication is better

Of course, it’s a nice thing to get paid to write code. Selling licenses is _one_ way to do that. But it carries a terrible price: you can’t share. That hurts producers much more than conventional wisdom would have you think. Because, as [James Burke](http://www.k-web.org) tried to point out in his landmark documentary, [Connections](http://ambrosevideo.com/displayitem.cfm?vid=854), inventions do not spring fully formed in the minds of a few brilliant inventors. They come instead out of the mixture of ideas that occurs in a free environment where ordinarily clever people freely share their ideas.

That’s an old idea in academia, but it’s the basis of free software collaboration and development.

For the do-it-yourselfer, though, free software is more than just a _good_ model for writing code, it’s often the _only_ model that will work. An amateur or do-it-yourself developer can get code written using a free model because they can get help from other interested amateurs or from pros who are often willing to lend their expertise to a fun and useful project. Even if you don’t get donations of actual code, it’s usually trivial to get comments and suggestions. I’ve long since lost count of the number of road blocks that have been cleared for me by a throw-away comment on a programming newsgroup or mailing list. There are sharp minds out there, and working on free projects with just a bit of skill gives you the credibility to tap them.

People want to help you because they know they’ll be contributing to a public good. You can surf that goodwill, and it’s really quite a rush!

So pick up a copy of a programming book or a free online tutorial. Learn to love text terminals and editors. Find your inner geek. Develop a little skill and see where it takes you—you just may find it an addictive thrill. Free software is fun to use—but it’s even more fun to write!

